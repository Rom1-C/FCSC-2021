# RSA-Destroyer (crypto, 200)



## Description du problème

On nous donne un message chiffré, l'exposant, le modulo et le code source qui a servit à créer le message chiffré:

```py
def fastPrime(bits, eps = 32):
	while True:
		a, e, u = getrandbits(eps), getrandbits(eps), getrandbits(4 * eps)
		p = a * (2 ** bits - e) + u
		if isPrime(p):
			return p

def generate(bits = 2048):
	p = fastPrime(bits // 2)
	q = fastPrime(bits // 2)
	return p * q, 2 ** 16 + 1

n, e = generate()

p = bytes_to_long(open("flag.txt", "rb").read())
c = pow(p, e, n)

print(f"e = {e}")
print(f"n = {n}")
print(f"c = {c}")

e = 65537
n = 444874973852804286630293120525019547982392964519934608680681255396764239795499482860997657663742247333836933457910503642061679607999128792657151145831533603267962151902191791568052924623477918783346790554917615006885807262798511378178431356140169891510484103567017335784087168191133679976921108092647227149255338118895695993606854195408940572577899625236666854544581041490770396755583819878794842828965377818593455075306655077757834318066860484956428681524881285058664687568640627516452658874124048546780999256640377399347893644988620246748059490751348919880389771785423781356133657866769589669296191804649195706447605778549172906037483
c = 95237912740655706597869523108017194269174342313145809624317482236690453533195825723998662803480781411928531102859302761153780930600026069381338457909962825300269319811329312349030179047249481841770850760719178786027583177746485281874469568361239865139247368477628439074063199551773499058148848583822114902905937101832069433266700866684389484684637264625534353716652481372979896491011990121581654120224008271898183948045975282945190669287662303053695007661315593832681112603350797162485915921143973984584370685793424167878687293688079969123983391456553965822470300435648090790538426859154898556069348437896975230111242040448169800372469
```

L'exposant est normal et le modulo n'est pas sur factor db ( bon après le ctf il y sera peut-être )  donc la seule partie intéressante est la génération de p et q avec la fonction fastPrime.

On peut remarquer que les nombres générés par la fonction ont une forme spéciale :

```
a * 2^1024 + ~2^128
```

Cela se vérifie en essayant la fonction:

```py
>>> from Crypto.Util.number import isPrime, bytes_to_long
>>> from Crypto.Random.random import getrandbits
>>>
>>> def fastPrime(bits, eps = 32):
...     while True:
...         a, e, u = getrandbits(eps), getrandbits(eps), getrandbits(4 * eps)
...         p = a * (2 ** bits - e) + u
...         if isPrime(p):
...             return p
...
>>> print(hex(fastPrime(1024)))
0xe8d208920000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001f79420c2cfb97cb842d1692b235771
```

On peut alors regarder si N a la même structure:

```py
>>> print(hex(444874973852804286630293120525019547982392964519934608680681255396764239795499482860997657663742247333836933457910503642061679607999128792657151145831533603267962151902191791568052924623477918783346790554917615006885807262798511378178431356140169891510484103567017335784087168191133679976921108092647227149255338118895695993606854195408940572577899625236666854544581041490770396755583819878794842828965377818593455075306655077757834318066860484956428681524881285058664687568640627516452658874124048546780999256640377399347893644988620246748059490751348919880389771785423781356133657866769589669296191804649195706447605778549172906037483))
0xbf0a8dd7d8f16cad000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001002c0b6fc6c3c2949b0a1e097f3c51eff2e89198000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000526e422445cbd24c429d60a4a3d75cfd20d09708a2945d9ad2d3b65a55f110eb
```

C'est le cas.

On peut donc décomposer p, q et N en 

```
p = a* 2^1024 + x
q = b* 2^1024 + y
N = a*b* 2^2048 + a* 2^1024*y + b* 2^1024 * x + x*y => 
N = a*b* 2^2048 + (a*y + b*x) * 2^1024 + x*y
```

A partir de là on peut trouver a et b puis x et y assez facilement.

Pour récupérer a\*b on modifie N et on le divise par 2^2048:

```py
N = 0xbf0a8dd7d8f16cad00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
ab = N/2**2048
print(ab)
#13765971169208528045
```

On connait donc a\*b, on utilise ensuite sage pour connaitre les diviseurs de a\*b et trouver a et b:

```py
ab = 13765971169208528045
l = divisors(13765971169208528045)
for a in l:
    for b in l:
        if a*b == ab and a<2**33 and b<2**33:
            print(a)
            print(b)
#3669050237
#3751916785
#3751916785
#3669050237
```

On a donc 2 résultats qui sont a\*b et b\*a, je choisis de prendre le premier résultat ce qui donne a = 3669050237 et b = 3751916785.

Pour trouver x et y on utilise la dernière partie de N qui est égal à x\*y. Pour ça on parcours les diviseurs de la dernière partie de N  (526e422445cbd24c429d60a4a3d75cfd20d09708a2945d9ad2d3b65a55f110eb) puis on sélectionne ceux qui vont par pair et qui ne sont pas trop petits. Il ne reste plus qu'à les tester, ce qui est très rapide.

```py
N = 444874973852804286630293120525019547982392964519934608680681255396764239795499482860997657663742247333836933457910503642061679607999128792657151145831533603267962151902191791568052924623477918783346790554917615006885807262798511378178431356140169891510484103567017335784087168191133679976921108092647227149255338118895695993606854195408940572577899625236666854544581041490770396755583819878794842828965377818593455075306655077757834318066860484956428681524881285058664687568640627516452658874124048546780999256640377399347893644988620246748059490751348919880389771785423781356133657866769589669296191804649195706447605778549172906037483;

a = 3669050237
b = 3751916785

p = a*2**1024
q = b*2**1024
d = Integer(int(0x526e422445cbd24c429d60a4a3d75cfd20d09708a2945d9ad2d3b65a55f110eb))
f = divisors(d)
c = []
for a in f:
    for b in f:
        if a*b == d and a > 2**20 and b > 2**20:
            c.append([a,b])

for a in c:
    if (p+a[0]) * (q+a[1]) == N:
        print(a)
#[155855460081744155068217508253103646077, 239224620263965184662787181879747443847]
```

On a trouvé notre x et notre y, ce qui nous donne:

```py
a = 3669050237
b = 3751916785

p = a*2**1024 + 155855460081744155068217508253103646077
q = b*2**1024 + 239224620263965184662787181879747443847
```

Il ne reste plus qu'à déchiffrer le message

```py
a = 3669050237
b = 3751916785
e = 65537
c = int(0x28e5d0538ff8822f2859895b9998f28459d5ef45177a1fd4277162cf63412318907dbc3750c47dfd79288ee14383a034815c8b1b71232a3930c334593ee3384c0ca1f924da4bb46a294d6f24431773ff46bc7b06d60e097f1fe229449b5ccb4613c856089ca2dbd6feae294f4a34f0fafaccf6351500ca3e1f43014959a457b6b6225561e2ec7813a7bfaab4b8d9df1b7164a990b781cfd242acb215facc570699909295da1ad580a3c26c4e6dae4f91d0b1061a1ead73fb10fd5a444d4b56db9b0565db0d5d66dfa053a8c7fe1333c523657b02581993f2bcbe5af00f4b8d05e4cef44c207e0cd0228f69514eabeaa8a1fb462417bc134fe02f80935f8baccd42835dad6aac10f5)

p = a*2**1024 + 155855460081744155068217508253103646077
q = b*2**1024 + 239224620263965184662787181879747443847
N = 444874973852804286630293120525019547982392964519934608680681255396764239795499482860997657663742247333836933457910503642061679607999128792657151145831533603267962151902191791568052924623477918783346790554917615006885807262798511378178431356140169891510484103567017335784087168191133679976921108092647227149255338118895695993606854195408940572577899625236666854544581041490770396755583819878794842828965377818593455075306655077757834318066860484956428681524881285058664687568640627516452658874124048546780999256640377399347893644988620246748059490751348919880389771785423781356133657866769589669296191804649195706447605778549172906037483;
d = pow(e,-1,(p-1)*(q-1))
print(long_to_bytes(pow(c,d,N)))
#b'FCSC{cd43566923980e47f6630e82c2d9a55b388f01043bc78b9ce3354ce02acf22e8}'
```

Et c'est flag.

C'était un challenge très intéressant car le problème est différent de ceux qu'on a l'habitude rencontrer.

Le code source et ma solution sont joint.
